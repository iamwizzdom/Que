<?php

namespace que\middleware;

use que\common\exception\QueException;
use que\common\validator\Track;
use que\http\HTTP;
use que\http\input\Input;
use que\route\Route;
use que\security\CSRF;
use que\security\Middleware;
use que\security\MiddlewareResponse;

class VerifyCsrfToken extends Middleware
{
    public function handle(Input $input): MiddlewareResponse
    {
        $route = Route::getCurrentRoute();

        if ($input->getRequest()->getMethod() !== "GET") {

            if ($route->isForbidCSRF() === true) {

                try {

                    $this->validateCSRF($input);

                    if ($route->getType() === 'api' || $route->getType() === 'resource') {
                        $input->getHeader()->set('X-Xsrf-Token', CSRF::getInstance()->getToken());
                        $input->getHeader()->set('X-Track-Token', Track::generateToken());
                    }

                } catch (QueException $e) {

                    $this->setAccess(false);
                    $this->setTitle($e->getTitle());
                    $this->setResponse($e->getMessage());
                    $this->setResponseCode(HTTP::EXPIRED_AUTHENTICATION);
                    return $this;
                }
            }
        }

        if ($route->isForbidCSRF() === true) CSRF::getInstance()->generateToken();
        return parent::handle($input); // TODO: Change the autogenerated stub
    }

    /**
     * @param Input $input
     * @throws QueException
     */
    private function validateCSRF(Input $input) {

        $token = $input->get('X-Csrf-Token');
        if (empty($token)) {
            foreach (
                [
                    'X-CSRF-TOKEN',
                    'x-csrf-token',
                    'csrf',
                    'Csrf',
                    'CSRF'
                ] as $key
            ) if (!empty($token = $input->get($key))) break;
        }

        CSRF::getInstance()->validateToken((!is_null($token) ? $token : ""));
    }
}