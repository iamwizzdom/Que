<?php
/**
 * Created by PhpStorm.
 * User: Wisdom Emenike
 * Date: 10/21/2017
 * Time: 10:58 PM
 */

namespace que\database\mysql;

use Exception;
use que\common\exception\PreviousException;
use que\common\exception\QueRuntimeException;
use que\database\connection\Connect;
use que\database\interfaces\drivers\Driver;
use que\database\interfaces\drivers\DriverQueryBuilder;
use que\database\interfaces\drivers\DriverResponse;
use que\database\interfaces\drivers\Observer;
use que\database\interfaces\drivers\ObserverSignal;
use que\database\interfaces\model\Model;
use que\database\model\ModelStack as ModelStackInterface;
use que\database\model\ModelStack;
use que\support\Config;
use que\template\Pagination;

class Query extends Connect
{

    /**
     * @var Query
     */
    private static Query $instance;

    /**
     * @var bool
     */
    private bool $paginate = false;

    /**
     * @var string
     */
    private string $tag = "";

    /**
     * @var int
     */
    private int $page = 0;

    /**
     * @var int
     */
    private int $recordPerPage = 0;

    /**
     * @var array
     */
    private array $primaryKeys = [];

    /**
     * Query constructor.
     */
    public function __construct()
    {
        $this->changeDriver(Config::get('database.default.driver', ''));
    }

    public function __destruct()
    {
        // TODO: Implement __destruct() method.
        parent::__destruct();
    }

    private function __clone()
    {
        // TODO: Implement __clone() method.
    }

    private function __wakeup()
    {
        // TODO: Implement __wakeup() method.
    }

    /**
     * @return Query
     */
    public static function getInstance(): Query
    {
        if (!isset(self::$instance))
            self::$instance = new self;
        return self::$instance;
    }

    protected function getDriver(): Driver
    {
        return parent::getDriver(); // TODO: Change the autogenerated stub
    }

    /**
     * @param bool $paginate
     */
    private function setPaginateStatus(bool $paginate)
    {
        $this->paginate = $paginate;
    }

    /**
     * @param string $tag
     */
    private function setTag(string $tag)
    {
        $this->tag = $tag;
    }

    /**
     * @param int $page
     */
    private function setPage(int $page)
    {
        $this->page = $page;
    }

    /**
     * @param int $recordPerPage
     */
    private function setRecordPerPage(int $recordPerPage)
    {
        $this->recordPerPage = $recordPerPage;
    }

    /**
     * @return bool
     */
    private function getPaginateStatus(): bool
    {
        return $this->paginate;
    }

    /**
     * @return string
     */
    public function getTag(): string
    {
        return $this->tag;
    }

    /**
     * @return int
     */
    private function getPage(): int
    {
        return $this->page;
    }

    /**
     * @return int
     */
    private function getRecordPerPage(): int
    {
        return $this->recordPerPage;
    }

    /**
     * @param string $tag
     * @param int $recordPerPage
     * @return Query
     */
    public function paginate(string $tag = "default", int $recordPerPage = DEFAULT_PAGINATION_RECORD_PER_PAGE): Query
    {
        $this->setPaginateStatus(true);
        $this->setRecordPerPage($recordPerPage ?: 1);
        $this->setTag($tag);
        $page = http()->_get()->get('p', 1);
        $this->setPage($page);
        return $this;
    }

    /**
     * @param bool $testMode
     * @return bool
     */
    public function transStart(bool $testMode = false): bool
    {
        if (!$this->isTransEnabled()) return false;
        return $this->transBegin($testMode);
    }

    /**
     * @param bool $testMode
     * @return bool
     */
    public function transBegin(bool $testMode = false): bool
    {

        if (!$this->isTransEnabled()) return false;
        elseif ($this->getTransDepth() > 0) {
            $this->transDepth++;
            return false;
        }

        $this->setTransSuccessful(($testMode === true));

        if ($this->trans_begin()) {
            $this->setTransSuccessful(true);
            $this->transDepth++;
            return true;
        }

        return false;
    }

    /**
     * @return bool
     */
    public function transComplete(): bool
    {
        if (!$this->isTransEnabled()) return false;

        if (!$this->isTransSuccessful()) {
            $this->transRollBack();
            return false;
        }
        return $this->transCommit();
    }

    /**
     * @return bool
     */
    public function transCommit(): bool
    {
        if (!$this->isTransEnabled() || $this->getTransDepth() <= 0) return false;
        elseif ($this->getTransDepth() > 1 || $this->commit()) {
            $this->transDepth--;
            return true;
        }
        return false;
    }

    /**
     * @return bool
     */
    public function transRollBack(): bool
    {
        if (!$this->isTransEnabled() || $this->getTransDepth() <= 0) return false;
        elseif ($this->getTransDepth() > 1 || $this->rollback()) {
            $this->transDepth--;
            return true;
        }
        return false;
    }

    /**
     * @return bool
     */
    private function trans_begin(): bool
    {
        return $this->getDriver()->beginTransaction();
    }

    /**
     * @return bool
     */
    private function commit(): bool
    {
        return $this->getDriver()->commit();
    }

    /**
     * @return bool
     */
    private function rollback(): bool
    {
        return $this->getDriver()->rollback();
    }

    /**
     * @param string $table
     * @param array $columns
     * @return QueryResponse
     */
    public function insert(string $table, array $columns): QueryResponse
    {
        $columns = $this->normalize_data($columns);
        $driver = $this->getDriver();

        if (!isset($this->primaryKeys[$table])) {
            $showTable = $this->show_table($table);
            $this->primaryKeys[$table] = $showTable->isSuccessful() ? $showTable->getQueryResponse() : 'id';
        }

        $model = \model(config("database.default.model"));
        if ($model !== null) {
            if (($implements = class_implements($model)) &&
                in_array(Model::class, $implements)) {
                $columns = (object) $columns;
                $model = new $model($columns, $table, $this->primaryKeys[$table]);
            }
        }

        if (!$model instanceof Model) {
            $columns = (object) $columns;
            $model = new \que\database\model\Model($columns, $table, $this->primaryKeys[$table]);
        }

        return $this->insertOps($table, $model, $driver);
    }

    /**
     * @param string $table
     * @param Model|null $model
     * @param Driver $driver
     * @param bool $retrying
     * @param Observer|null $observer
     * @param int $attempts
     * @return QueryResponse
     */
    private function insertOps(string $table, Model $model,
                               Driver $driver, bool $retrying = false,
                               Observer $observer = null,
                               int $attempts = 0): QueryResponse
    {
        $builder = $driver->getQueryBuilder();
        $builder->setQueryType(DriverQueryBuilder::INSERT);
        $builder->buildQuery($table, $model->getArray());

        if ($observer === null) {
            $observer = config("database.observers.{$table}");
            if ($observer !== null && class_exists($observer, true) &&
                (($implements = class_implements($observer)) &&
                    in_array(Observer::class, $implements))) {

                $observer = new $observer(new ObserverSignal());
                if ($observer instanceof Observer) {
                    //Notify observer that insert operation has started
                    $observer->onCreating($model);
                }
            }

        }

        if ($observer instanceof Observer) {

            //Check if observer wants to discontinue the insert operation
            if (!$observer->getSignal()->continueOperation()) {

                return new QueryResponse($this->getCustomDriverResponse($builder, [
                    "Observer for '{$table}' table stopped insert operation"
                ], "00101"), $builder->getQueryType(), $table);
            }

            //Begin a transaction so that we can roll back if the developer
            //asks us to do so via the observer signal
            if (!$this->isTransEnabled()) $this->setTransEnabled(true);
            $this->transBegin();
        }

        $response = $driver->exec($builder);

        if (!$response->isSuccessful()) {

            if ($observer instanceof Observer && $model instanceof Model) {

                //Check that operation in not already on retry mode
                if (!$retrying) {

                    //Notify observer that operation failed
                    $observer->onCreateFailed($model, $response->getErrors(), $response->getErrorCode());

                    $signal = $observer->getSignal();

                    //Check if observer wants to retry the operation again
                    if ($signal->retryOperation()) {

                        //Notify observer that retry operation has started
                        $observer->onCreateRetryStarted($model);

                        try {

                            $totalAttempts = 0;

                            $retryResponse = retry(function ($attempt) use ($table, $driver, $builder, $observer, $model, &$totalAttempts) {

                                $totalAttempts = $attempt;

                                return $this->insertOps($table, $model, $driver, true, $observer, $attempt);

                            }, $signal->getTrials(), $signal->getInterval() * 1000, function (QueryResponse $retryResponse) {
                                return $retryResponse->isSuccessful();
                            });

                            //Notify observer that retry operation has completed
                            $observer->onCreateRetryComplete($model, $retryResponse instanceof QueryResponse ?
                                $retryResponse->isSuccessful() : false, $totalAttempts);

                            if ($retryResponse instanceof QueryResponse) return $retryResponse;

                        } catch (Exception $e) {
                        }
                    }
                }
            }

            if ($retrying && $attempts < $observer->getSignal()->getTrials())
                return new QueryResponse($response, $builder->getQueryType(), $table);

            $this->rollbackTrans();

            if ($driver->isInDebugMode()) {

                $errors = serializer_recursive($response->getErrors(), " -- ", function ($error) {
                    return !empty($error);
                });

                throw new QueRuntimeException("Error: {$errors} \nQuery: '{$response->getQueryString()}'\n",
                    "Database Error", E_USER_ERROR, 0,
                    PreviousException::getInstance());
            }

        } elseif ($observer instanceof Observer && $model instanceof Model) {
            $model->offsetSet($this->primaryKeys[$table], $response->getLastInsertID());
            $model->refresh();
            $observer->onCreated($model);
        }

        if ($observer instanceof Observer) {

            //Check if observer wants to undo the insert operation
            if ($observer->getSignal()->undoOperation()) {

                $this->rollbackTrans();

                return new QueryResponse($this->getCustomDriverResponse($builder, [
                    "Observer for '{$table}' table asked to undo the insert operation"
                ], "00101"), $builder->getQueryType(), $table);
            } else {

                //Here we complete the transaction, since the developer
                //didn't as us to undo the operation
                $this->transComplete();
                $this->setTransEnabled(false);
            }
        }

        return new QueryResponse($response, $builder->getQueryType(), $table);
    }

    /**
     * @param string $table
     * @param array|null $where
     * @return QueryResponse
     */
    public function delete(string $table, array $where = null): QueryResponse
    {
        $this->validateWhereQuery($where);

        $where = $where !== null ? $this->normalize_data($where, true) : $where;
        $driver = $this->getDriver();
        $builder = $driver->getQueryBuilder();

        if (!isset($this->primaryKeys[$table])) {
            $showTable = $this->show_table($table);
            $this->primaryKeys[$table] = $showTable->isSuccessful() ? $showTable->getQueryResponse() : 'id';
        }

        $modelStack = null;

        if (($model = \model(config("database.default.model"))) !== null) {
            if (($implements = class_implements($model)) &&
                in_array(Model::class, $implements)) {

                $record = $this->select($table, '*', $where);
                if ($record->isSuccessful()) {
                    $records = $record->getQueryResponse();
                    if (is_array($records)) {
                        array_callback($records, function ($record) use ($model, $table) {
                            return new $model($record, $table, $this->primaryKeys[$table]);
                        });
                        $modelStack = new ModelStack($records);
                    }
                } else {
                    $builder->setQueryType(DriverQueryBuilder::DELETE);
                    $builder->buildQuery($table, null, $where);
                    $error = [$record->getQueryError()];
                    return new QueryResponse($this->getCustomDriverResponse($builder, $error,
                        $record->getQueryErrorCode()), $builder->getQueryType(), $table);
                }
            }
        }

        if (!$modelStack instanceof ModelStackInterface) {

            $record = $this->select($table, '*', $where);
            if ($record->isSuccessful()) {
                $records = $record->getQueryResponse();
                if (is_array($records)) {
                    array_callback($records, function ($record) use ($table) {
                        return new \que\database\model\Model($record, $table, $this->primaryKeys[$table]);
                    });
                    $modelStack = new ModelStack($records);
                }
            } else {
                $builder->setQueryType(DriverQueryBuilder::DELETE);
                $builder->buildQuery($table, null, $where);
                $error = [$record->getQueryError()];
                return new QueryResponse($this->getCustomDriverResponse($builder, $error,
                    $record->getQueryErrorCode()), $builder->getQueryType(), $table);
            }

        }

        return $this->deleteOps($table, $modelStack, $driver);
    }

    /**
     * @param string $table
     * @param ModelStackInterface $modelStack
     * @param Driver $driver
     * @param Observer|null $observer
     * @param bool $retrying
     * @param int $attempts
     * @return QueryResponse
     */
    private function deleteOps(string $table, ModelStackInterface $modelStack, Driver $driver,
                               Observer $observer = null, bool $retrying = false,
                               int $attempts = 0): QueryResponse
    {

        if ($observer === null) {

            $observer = config("database.observers.{$table}");

            if ($observer !== null && class_exists($observer, true)) {

                if (($implements = class_implements($observer)) &&
                    in_array(Observer::class, $implements)) {

                    $observer = new $observer(new ObserverSignal());
                    if ($observer instanceof Observer) {
                        //Notify observer that insert operation has started
                        $observer->onDeleting($modelStack);
                    }
                }
            }
        }

        $builder = $driver->getQueryBuilder();
        $builder->setQueryType(DriverQueryBuilder::DELETE);

        $where = [];
        foreach ($modelStack as $model) {
            if (!$model instanceof Model) continue;
            $where[$model->getPrimaryKey()][] = $model->getValue($model->getPrimaryKey());
        }

        $builder->buildQuery($table, null, ['AND' => $where]);

        if ($observer instanceof Observer) {
            //Check if observer wants to discontinue the delete operation
            if (!$observer->getSignal()->continueOperation()) {

                return new QueryResponse($this->getCustomDriverResponse($builder, [
                    "Observer for '{$table}' table stopped delete operation"
                ], "00101"), $builder->getQueryType(), $table);
            }

            //Begin a transaction so that we can roll back if the developer
            //asks us to do so via the observer signal
            if (!$this->isTransEnabled()) $this->setTransEnabled(true);
            $this->transBegin();
        }

        if ($modelStack->isEmpty()) {

            return new QueryResponse($this->getCustomDriverResponse($builder, [
                "Observer for '{$table}' table removed all records to be deleted thereby stopping delete operation"
            ], "00101"), $builder->getQueryType(), $table);
        }

        $response = $driver->exec($builder);

        if (!$response->isSuccessful()) {

            //Check that operation in not already on retry mode
            if (!$retrying && $observer instanceof Observer) {

                //Notify observer that operation failed
                $observer->onDeleteFailed($modelStack, $response->getErrors(), $response->getErrorCode());

                $signal = $observer->getSignal();

                //Check if observer wants to retry the operation again
                if ($signal->retryOperation()) {

                    //Notify observer that retry operation has started
                    $observer->onDeleteRetryStarted($modelStack);

                    try {

                        $totalAttempts = 0;

                        $retryResponse = retry(function ($attempt) use ($table, $modelStack, $driver, $observer, &$totalAttempts) {

                            $totalAttempts = $attempt;

                            return $this->deleteOps($table, $modelStack, $driver, $observer, true, $attempt);

                        }, $signal->getTrials(), $signal->getInterval() * 1000, function (QueryResponse $retryResponse) {
                            return $retryResponse->isSuccessful();
                        });

                        //Notify observer that retry operation has completed
                        $observer->onDeleteRetryComplete($modelStack, $retryResponse instanceof QueryResponse ?
                            $retryResponse->isSuccessful() : false, $totalAttempts);

                        if ($retryResponse instanceof QueryResponse) return $retryResponse;

                    } catch (Exception $e) {
                    }
                }
            }

            if ($retrying && $attempts < $observer->getSignal()->getTrials())
                return new QueryResponse($response, $builder->getQueryType(), $table);

            $this->rollbackTrans();

            if ($driver->isInDebugMode()) {

                $errors = serializer_recursive($response->getErrors(), " -- ", function ($error) {
                    return !empty($error);
                });

                throw new QueRuntimeException("Error: {$errors} \nQuery: '{$response->getQueryString()}'\n",
                    "Database Error", E_USER_ERROR, 0,
                    PreviousException::getInstance());
            }

        } elseif ($observer instanceof Observer && $modelStack instanceof ModelStackInterface) $observer->onDeleted($modelStack);

        if ($observer instanceof Observer) {

            //Check if observer wants to undo the delete operation
            if ($observer->getSignal()->undoOperation()) {

                $this->rollbackTrans();

                return new QueryResponse($this->getCustomDriverResponse($builder, [
                    "Observer for '{$table}' table asked to undo the delete operation"
                ], "00101"), $builder->getQueryType(), $table);
            } else {

                //Here we complete the transaction, since the developer
                //didn't as us to undo the operation
                $this->transComplete();
                $this->setTransEnabled(false);
            }
        }

        return new QueryResponse($response, $builder->getQueryType(), $table);
    }

    /**
     * @param string $table
     * @param array|null $where
     * @param array|null $join
     * @return QueryResponse
     */
    public function check(string $table, array $where = null, array $join = null): QueryResponse
    {
        return $this->select($table, "*", $where, $join, 1);
    }

    /**
     * @param string $table
     * @param $id
     * @param string $column
     * @param string $columns
     * @param array|null $join
     * @return QueryResponse
     */
    public function find(string $table, $id, string $column = 'id', $columns = '*', array $join = null)
    {
        return $this->select($table, $columns, [
            'AND' => [
                $column => $id
            ]
        ], $join, 1);
    }

    /**
     * @param string $table
     * @param null $id
     * @param string $column
     * @param string $columns
     * @param array|null $join
     * @param array|null $order_by
     * @param string|null $group_by
     * @return QueryResponse
     */
    public function findAll(string $table, $id = null, string $column = 'id',
                            $columns = '*', array $join = null,
                            array $order_by = null, string $group_by = null)
    {
        $where = null;

        if (!empty($id)) {
            $where = [
                'AND' => [
                    $column => $id
                ]
            ];
        }
        return $this->select($table, $columns, $where, $join, null, $order_by, $group_by);
    }

    /**
     * @param string $table
     * @param $columns
     * @param array|null $where
     * @param array|null $join
     * @param null $limit
     * @param array|null $order_by
     * @param string|null $group_by
     * @return QueryResponse
     */
    public function select(string $table, $columns, array $where = null, array $join = null,
                           $limit = null, array $order_by = null, string $group_by = null): QueryResponse
    {
        $this->validateWhereQuery($where);

        if ($this->getPaginateStatus() === true) {

            $count = $this->count($table, str_contains($columns,
                ',') ? null : $columns, $where, $join, null, null, $group_by);

            $totalPages = ceil(($totalRecord = ($count->isSuccessful() ?
                    $count->getQueryResponse() : 0)) / $this->getRecordPerPage());

            if ($totalPages && $this->getPage() > $totalPages) {
                $this->setPage($totalPages);
            }

            $limit = [(($this->getPage() - 1) * $this->getRecordPerPage()), $this->getRecordPerPage()];

            $startPage = 1;
            $endPage = ($totalPages > 10 ? 11 : $totalPages);
            $totalBatch = $this->round_up_to_nearest(($totalPages / 10), 10);
            $currentPage = $this->getPage();

            for ($i = 1; $i < $totalBatch; $i++) {
                $startPage = ($i > 1 ? (($i - 1) * 10) : $i);
                $endPage = ($i * 10);
                if ($currentPage >= $startPage && $currentPage <= $endPage) {
                    $startPage = ($startPage > 1 ? ($startPage + 1) : $startPage);
                    $endPage = ($endPage > $totalPages ? $totalPages : $endPage);
                    break;
                }
            }

            Pagination::getInstance()->paginate(
                $this->getPage(),
                $startPage,
                $endPage,
                $totalPages,
                $totalRecord,
                $this->getTag()
            );

            $this->setPaginateStatus(false);

        }

        $where = $where !== null ? $this->normalize_data($where, true) : $where;

        $driver = $this->getDriver();

        $builder = $driver->getQueryBuilder();
        $builder->setQueryType(DriverQueryBuilder::SELECT);
        $builder->buildQuery($table, $columns, $where, $join, $limit, $order_by, $group_by);

        $response = $driver->exec($builder);

        if (!$response->isSuccessful()) {

            $this->rollbackTrans();

            if ($driver->isInDebugMode()) {

                $errors = serializer_recursive($response->getErrors(), " -- ", function ($error) {
                    return !empty($error);
                });

                throw new QueRuntimeException("Error: {$errors} \nQuery: '{$response->getQueryString()}'\n",
                    "Database Error", E_USER_ERROR, 0,
                    PreviousException::getInstance());
            }
        }

        return new QueryResponse($response, $builder->getQueryType(), $table);
    }

    /**
     * @param string $table
     * @param string $query
     * @param array $queryBindValues
     * @return QueryResponse
     */
    public function raw_select_query(string $table, string $query, array $queryBindValues): QueryResponse
    {
        $driver = $this->getDriver();

        $builder = $driver->getQueryBuilder();
        $builder->setQueryType(DriverQueryBuilder::RAW_SELECT);
        $builder->setQuery($query);
        $builder->setQueryBindValues($queryBindValues);

        $response = $driver->exec($builder);

        if (!$response->isSuccessful()) {

            $this->rollbackTrans();

            if ($driver->isInDebugMode()) {

                $errors = serializer_recursive($response->getErrors(), " -- ", function ($error) {
                    return !empty($error);
                });

                throw new QueRuntimeException("Error: {$errors} \nQuery: '{$response->getQueryString()}'\n",
                    "Database Error", E_USER_ERROR, 0,
                    PreviousException::getInstance());
            }
        }

        return new QueryResponse($response, $builder->getQueryType(), $table);
    }

    /**
     * @param string $table
     * @param string $query
     * @param array $queryBindValues
     * @return QueryResponse
     */
    public function raw_query(string $table, string $query, array $queryBindValues): QueryResponse
    {
        $driver = $this->getDriver();

        $builder = $driver->getQueryBuilder();
        $builder->setQueryType(DriverQueryBuilder::RAW_QUERY);
        $builder->setQuery($query);
        $builder->setQueryBindValues($queryBindValues);

        $response = $driver->exec($builder);

        if (!$response->isSuccessful()) {

            $this->rollbackTrans();

            if ($driver->isInDebugMode()) {

                $errors = serializer_recursive($response->getErrors(), " -- ", function ($error) {
                    return !empty($error);
                });

                throw new QueRuntimeException("Error: {$errors} \nQuery: '{$response->getQueryString()}'\n",
                    "Database Error", E_USER_ERROR, 0,
                    PreviousException::getInstance());
            }
        }

        return new QueryResponse($response, $builder->getQueryType(), $table);
    }

    /**
     * @param string $table
     * @param string $query
     * @param array $queryBindValues
     * @return QueryResponse
     */
    public function raw_object(string $table, string $query, array $queryBindValues): QueryResponse
    {
        $driver = $this->getDriver();

        $builder = $driver->getQueryBuilder();
        $builder->setQueryType(DriverQueryBuilder::RAW_OBJECT);
        $builder->setQuery($query);
        $builder->setQueryBindValues($queryBindValues);

        $response = $driver->exec($builder);

        if (!$response->isSuccessful()) {

            if ($this->getTransDepth() > 0) $this->setTransSuccessful(false);

            while ($this->getTransDepth() !== 0) {
                $depth = $this->getTransDepth();
                $this->transComplete();
                if ($depth === $this->getTransDepth()) break;
            }

            if ($driver->isInDebugMode()) {

                $errors = serializer_recursive($response->getErrors(), " -- ", function ($error) {
                    return !empty($error);
                });

                throw new QueRuntimeException("Error: {$errors} \nQuery: '{$response->getQueryString()}'\n",
                    "Database Error", E_USER_ERROR, 0,
                    PreviousException::getInstance());
            }
        }

        return new QueryResponse($response, $builder->getQueryType(), $table);
    }

    /**
     * @param string $table
     * @param string|array $columns
     * @param array|null $where
     * @return QueryResponse
     */
    public function update(string $table, $columns, array $where = null): QueryResponse
    {
        $this->validateWhereQuery($where);

        $where = $where !== null ? $this->normalize_data($where, true) : $where;
        $driver = $this->getDriver();
        $builder = $driver->getQueryBuilder();

        if (!isset($this->primaryKeys[$table])) {
            $showTable = $this->show_table($table);
            $this->primaryKeys[$table] = $showTable->isSuccessful() ? $showTable->getQueryResponse() : 'id';
        }

        $modelStack = null;

        if (($model = \model(config("database.default.model"))) !== null) {
            if (($implements = class_implements($model)) &&
                in_array(Model::class, $implements)) {

                $record = $this->select($table, '*', $where);
                if ($record->isSuccessful()) {
                    $records = $record->getQueryResponse();
                    if (is_array($records)) {
                        array_callback($records, function ($record) use ($model, $table) {
                            return new $model($record, $table, $this->primaryKeys[$table]);
                        });
                        $modelStack = new ModelStack($records);
                    }
                } else {
                    $builder->setQueryType(DriverQueryBuilder::DELETE);
                    $builder->buildQuery($table, null, $where);
                    $error = [$record->getQueryError()];
                    return new QueryResponse($this->getCustomDriverResponse($builder, $error,
                        $record->getQueryErrorCode()), $builder->getQueryType(), $table);
                }
            }
        }

        if (!$modelStack instanceof ModelStackInterface) {

            $record = $this->select($table, '*', $where);
            if ($record->isSuccessful()) {
                $records = $record->getQueryResponse();
                if (is_array($records)) {
                    array_callback($records, function ($record) use ($table) {
                        return new \que\database\model\Model($record, $table, $this->primaryKeys[$table]);
                    });
                    $modelStack = new ModelStack($records);
                }
            } else {
                $builder->setQueryType(DriverQueryBuilder::DELETE);
                $builder->buildQuery($table, null, $where);
                $error = [$record->getQueryError()];
                return new QueryResponse($this->getCustomDriverResponse($builder, $error,
                    $record->getQueryErrorCode()), $builder->getQueryType(), $table);
            }

        }

        return $this->updateOps($table, $columns, $modelStack, $driver);
    }

    /**
     * @param string $table
     * @param array $columns
     * @param ModelStackInterface $modelStack
     * @param Driver $driver
     * @param Observer|null $observer
     * @param bool $retrying
     * @param int $attempts
     * @return QueryResponse
     */
    private function updateOps(string $table, array $columns, ModelStackInterface $modelStack, Driver $driver,
                               Observer $observer = null, bool $retrying = false,
                               int $attempts = 0): QueryResponse
    {

        if ($observer === null) {

            $observer = config("database.observers.{$table}");

            if ($observer !== null && class_exists($observer, true)) {

                if (($implements = class_implements($observer)) &&
                    in_array(Observer::class, $implements)) {

                    $observer = new $observer(new ObserverSignal());
                    if ($observer instanceof Observer) {
                        //Notify observer that insert operation has started
                        $observer->onUpdating($modelStack);
                    }
                }
            }
        }

        $builder = $driver->getQueryBuilder();
        $builder->setQueryType(DriverQueryBuilder::UPDATE);

        $where = [];
        foreach ($modelStack as $model) {
            if (!$model instanceof Model) continue;
            $where[$model->getPrimaryKey()][] = $model->getValue($model->getPrimaryKey());
        }

        $builder->buildQuery($table, $this->normalize_data($columns), ['AND' => $where]);

        if ($observer instanceof Observer) {
            //Check if observer wants to discontinue the update operation
            if (!$observer->getSignal()->continueOperation()) {

                return new QueryResponse($this->getCustomDriverResponse($builder, [
                    "Observer for '{$table}' table stopped update operation"
                ], "00101"), $builder->getQueryType(), $table);
            }

            //Begin a transaction so that we can roll back if the developer
            //asks us to do so via the observer signal
            if (!$this->isTransEnabled()) $this->setTransEnabled(true);
            $this->transBegin();
        }

        if ($modelStack->isEmpty()) {

            return new QueryResponse($this->getCustomDriverResponse($builder, [
                "Observer for '{$table}' table removed all records to be updated thereby stopping update operation"
            ], "00101"), $builder->getQueryType(), $table);
        }

        $response = $driver->exec($builder);

        if (!$response->isSuccessful()) {

            //Check that operation in not already on retry mode
            if (!$retrying && $observer instanceof Observer) {

                //Notify observer that operation failed
                $observer->onUpdateFailed($modelStack, $response->getErrors(), $response->getErrorCode());

                $signal = $observer->getSignal();

                //Check if observer wants to retry the operation again
                if ($signal->retryOperation()) {

                    //Notify observer that retry operation has started
                    $observer->onUpdateRetryStarted($modelStack);

                    try {

                        $totalAttempts = 0;

                        $retryResponse = retry(function ($attempt) use ($table, $columns, $modelStack, $driver, $observer, &$totalAttempts) {

                            $totalAttempts = $attempt;

                            return $this->updateOps($table, $columns, $modelStack, $driver, $observer, true, $attempt);

                        }, $signal->getTrials(), $signal->getInterval() * 1000, function (QueryResponse $retryResponse) {
                            return $retryResponse->isSuccessful();
                        });

                        //Notify observer that retry operation has completed
                        $observer->onUpdateRetryComplete($modelStack, $retryResponse instanceof QueryResponse ?
                            $retryResponse->isSuccessful() : false, $totalAttempts);

                        if ($retryResponse instanceof QueryResponse) return $retryResponse;

                    } catch (Exception $e) {
                    }
                }
            }

            if ($retrying && $attempts < $observer->getSignal()->getTrials())
                return new QueryResponse($response, $builder->getQueryType(), $table);

            $this->rollbackTrans();

            if ($driver->isInDebugMode()) {

                $errors = serializer_recursive($response->getErrors(), " -- ", function ($error) {
                    return !empty($error);
                });

                throw new QueRuntimeException("Error: {$errors} \nQuery: '{$response->getQueryString()}'\n",
                    "Database Error", E_USER_ERROR, 0,
                    PreviousException::getInstance());
            }

        } elseif ($observer instanceof Observer && $modelStack instanceof ModelStackInterface) {
            $updatedStack = clone $modelStack;
            foreach ($modelStack as $m) {
                if (!$m instanceof Model) continue;
                $m = clone $m;
                $updatedStack->addModel($m);
            }
            $updatedStack->map(function (Model $model) use ($columns) {
                foreach ($columns as $key => $value) $model->offsetSet($key, $value);
            });
            $observer->onUpdated($updatedStack, $modelStack);
        }

        if ($observer instanceof Observer) {

            //Check if observer wants to undo the update operation
            if ($observer->getSignal()->undoOperation()) {

                $this->rollbackTrans();

                return new QueryResponse($this->getCustomDriverResponse($builder, [
                    "Observer for '{$table}' table asked to undo the update operation"
                ], "00101"), $builder->getQueryType(), $table);
            } else {

                //Here we complete the transaction, since the developer
                //didn't as us to undo the operation
                $this->transComplete();
                $this->setTransEnabled(false);
            }
        }

        return new QueryResponse($response, $builder->getQueryType(), $table);
    }

    /**
     * @param string $table
     * @param string|array $columns
     * @param array|null $where
     * @param null $join
     * @param null $limit
     * @param array|null $order_by
     * @param string|null $group_by
     * @return QueryResponse
     */
    public function count(string $table, $columns = null, array $where = null, $join = null,
                          $limit = null, array $order_by = null, string $group_by = null): QueryResponse
    {
        $this->validateWhereQuery($where);

        $driver = $this->getDriver();

        $builder = $driver->getQueryBuilder();
        $builder->setQueryType(DriverQueryBuilder::COUNT);

        if ($columns === null) {
            $showTable = $this->show_table($table);
            $columns = $showTable->isSuccessful() ? $showTable->getQueryResponse() : '*';
        }

        $builder->buildQuery($table, $columns, $where, $join, $limit, $order_by, $group_by);

        $response = $driver->exec($builder);

        if (!$response->isSuccessful()) {

            $this->rollbackTrans();

            if ($driver->isInDebugMode()) {

                $errors = serializer_recursive($response->getErrors(), " -- ", function ($error) {
                    return !empty($error);
                });

                throw new QueRuntimeException("Error: {$errors} \nQuery: '{$response->getQueryString()}'\n",
                    "Database Error", E_USER_ERROR, 0,
                    PreviousException::getInstance());
            }
        }

        return new QueryResponse($response, $builder->getQueryType(), $table);
    }

    /**
     * @param string $table
     * @param string|array $columns
     * @param array|null $where
     * @param null $join
     * @param null $limit
     * @param array|null $order_by
     * @param string|null $group_by
     * @return QueryResponse
     */
    public function avg(string $table, $columns, array $where = null, $join = null,
                        $limit = null, array $order_by = null, string $group_by = null): QueryResponse
    {
        $this->validateWhereQuery($where);

        $driver = $this->getDriver();

        $builder = $driver->getQueryBuilder();
        $builder->setQueryType(DriverQueryBuilder::AVG);
        $builder->buildQuery($table, $columns, $where, $join, $limit, $order_by, $group_by);

        $response = $driver->exec($builder);

        if (!$response->isSuccessful()) {

            $this->rollbackTrans();

            if ($driver->isInDebugMode()) {

                $errors = serializer_recursive($response->getErrors(), " -- ", function ($error) {
                    return !empty($error);
                });

                throw new QueRuntimeException("Error: {$errors} \nQuery: '{$response->getQueryString()}'\n",
                    "Database Error", E_USER_ERROR, 0,
                    PreviousException::getInstance());
            }
        }

        return new QueryResponse($response, $builder->getQueryType(), $table);
    }

    /**
     * @param string $table
     * @param string $columns
     * @param array|null $where
     * @param null $join
     * @param null $limit
     * @param array|null $order_by
     * @param string|null $group_by
     * @return QueryResponse
     */
    public function sum(string $table, $columns, array $where = null, $join = null,
                        $limit = null, array $order_by = null, string $group_by = null): QueryResponse
    {
        $this->validateWhereQuery($where);

        $driver = $this->getDriver();

        $builder = $driver->getQueryBuilder();
        $builder->setQueryType(DriverQueryBuilder::SUM);
        $builder->buildQuery($table, $columns, $where, $join, $limit, $order_by, $group_by);

        $response = $driver->exec($builder);

        if (!$response->isSuccessful()) {

            $this->rollbackTrans();

            if ($driver->isInDebugMode()) {

                $errors = serializer_recursive($response->getErrors(), " -- ", function ($error) {
                    return !empty($error);
                });

                throw new QueRuntimeException("Error: {$errors} \nQuery: '{$response->getQueryString()}'\n",
                    "Database Error", E_USER_ERROR, 0,
                    PreviousException::getInstance());
            }
        }

        return new QueryResponse($response, $builder->getQueryType(), $table);
    }

    /**
     * @param string $table
     * @return QueryResponse
     */
    private function show_table(string $table): QueryResponse
    {
        $driver = $this->getDriver();
        $builder = $driver->getQueryBuilder();
        $builder->setQueryType(DriverQueryBuilder::SHOW);
        $builder->buildQuery($table, null);
        $response = $driver->exec($builder);
        return new QueryResponse($response, $builder->getQueryType(), $table);
    }

    /**
     * @param $n
     * @param int $x
     * @return float|int
     */
    private function round_up_to_nearest($n, $x = 5)
    {
        return ($n % $x === 0 && !is_float(($n / $x))) ? round($n) : round((($n + $x / 2) / $x)) * $x;
    }

    /**
     * @param array $data
     * @param bool $recursive
     * @return array
     */
    private function normalize_data(array $data, bool $recursive = false): array
    {
        if ($recursive) {
            array_callback_recursive($data, function ($value) {
                return is_object($value) ? $this->mark_down($value) : $this->escape_string($value);
            });
        } else {
            array_callback($data, function ($value) {
                return (is_array($value) || is_object($value)) ? $this->mark_down($value) : $this->escape_string($value);
            });
        }
        return $data;
    }

    /**
     * @param $data
     * @return string
     */
    private function mark_down($data)
    {
        $type = gettype($data);
        $can_wakeup = "false";
        if (is_object($data) && (($class_name = get_class($data)) != \stdClass::class)
            && class_exists($class_name, true)) {
            $type = "class";
            if (method_exists($data, '__wakeup') &&
                is_callable([$data, '__wakeup'])) $can_wakeup = "true";
        }
        $data = serialize($data);
        return "[{$data}]({$type})({$can_wakeup})";
    }

    /**
     * @param array $where
     */
    private function validateWhereQuery(array $where = null) {
        if ($where !== null) {
            $keys = array_keys($where);
            $keys = array_map(function ($key) {
                return strtoupper($key);
            }, $keys);
            if (!in_array('AND', $keys) &&
                !in_array('OR', $keys)) throw new QueRuntimeException(
                "Invalid WHERE query. Your WHERE query must start with an 'OR' or 'AND' index",
                "Database Error", E_USER_ERROR, 0, PreviousException::getInstance(2));
        }
    }

    /**
     * @param DriverQueryBuilder $builder
     * @param array $errors
     * @param string $errorCode
     * @return DriverResponse|__anonymous@34526
     */
    private function getCustomDriverResponse(DriverQueryBuilder $builder, array $errors, string $errorCode)
    {

        $response = new class implements DriverResponse {

            public array $errors = [];
            public string $errorCode = "";
            public string $query = '';

            /**
             * @inheritDoc
             */
            public function isSuccessful(): bool
            {
                // TODO: Implement isSuccessful() method.
                return false;
            }

            /**
             * @inheritDoc
             */
            public function getResponse()
            {
                // TODO: Implement getResponse() method.
                return null;
            }

            /**
             * @inheritDoc
             */
            public function getLastInsertID(): int
            {
                // TODO: Implement getLastInsertID() method.
                return 0;
            }

            /**
             * @inheritDoc
             */
            public function getAffectedRows(): int
            {
                // TODO: Implement getAffectedRows() method.
                return 0;
            }

            /**
             * @inheritDoc
             */
            public function getErrors(): array
            {
                // TODO: Implement getErrors() method.
                return $this->errors;
            }

            /**
             * @inheritDoc
             */
            public function getErrorCode(): string
            {
                // TODO: Implement getErrorCode() method.
                return $this->errorCode;
            }

            /**
             * @inheritDoc
             */
            public function getQueryString(): string
            {
                // TODO: Implement getQueryString() method.
                return $this->query;
            }
        };

        $response->query = $builder->getQuery();
        $response->errors = $errors;
        $response->errorCode = $errorCode;

        return $response;
    }

    private function rollbackTrans() {

        if ($this->getTransDepth() > 0) $this->setTransSuccessful(false);

        while ($this->getTransDepth() !== 0) {
            $depth = $this->getTransDepth();
            $this->transComplete();
            if ($depth === $this->getTransDepth()) break;
        }
    }
}